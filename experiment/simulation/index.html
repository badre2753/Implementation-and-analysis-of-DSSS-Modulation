<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSSS System Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        h1 {
            margin-bottom: 10px;
        }

        #kit {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1400px;
            width: 100%;
            position: relative;
        }

        .module {
            background: #fff;
            border: 2px solid #666;
            border-radius: 8px;
            padding: 10px;
            width: 280px;
            box-sizing: border-box;
            user-select: none;
            position: relative;
            z-index: 1;
        }

        .module h2 {
            font-size: 18px;
            margin: 0 0 10px 0;
            text-align: center;
        }

        .ports-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .port-block {
            text-align: center;
        }

        .port-label {
            font-size: 12px;
            margin-top: 4px;
        }

        .port {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 auto;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .port:hover {
            transform: scale(1.2);
        }

        .port.selected {
            transform: scale(1.3);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .input-port {
            background-color: black;
            border: 1.5px solid #333;
        }

        .output-port {
            background-color: red;
            border: 1.5px solid #800;
        }

        button {
            background-color: green;
            color: white;
            font-weight: bold;
            border: none;
            padding: 6px 10px;
            margin: 4px;
            cursor: pointer;
            border-radius: 5px;
            user-select: none;
            font-size: 14px;
            transition: transform 0.1s ease;
        }

        #powerBtn.off {
            background-color: #f44336;
        }
        #powerBtn.on {
            background-color: #4CAF50;
        }

        .box {
            padding: 20px;
            background-color: #f0f0f0;
            text-align: center;
            border-top: 2px solid #000;
        }

        .box-image {
            width: 101%;
            height: auto;
            margin-bottom: 3px;
        }

        button:active {
            transform: scale(0.9);
        }

        .control-group {
            text-align: center;
            margin-bottom: 10px;
        }

        .control-label {
            margin-bottom: 6px;
            font-weight: 600;
        }

        #binaryInput {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        #binaryInput label {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
        }

        #binaryInput input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .connection {
            position: absolute;
            background-color: #2196F3;
            height: 3px;
            transform-origin: 0 0;
            z-index: 0;
            pointer-events: none;
        }

        .temp-connection {
            position: absolute;
            background-color: #FF9800;
            height: 3px;
            transform-origin: 0 0;
            z-index: 2;
            pointer-events: none;
        }

        .connection-label {
            position: absolute;
            background-color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            color: #333;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 2;
        }

        #statusMessage {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #f44336;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
            display: none;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Oscilloscope modal styles */
        #oscilloscopeModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        #oscilloscopeContent {
            background-color: #222;
            padding: 20px;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            position: relative;
            box-sizing: border-box;
        }
        
        #oscilloscopeClose {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        
        #oscilloscopeDisplay {
            width: 100%;
            height: 300px;
            background-color: black;
            border: 2px solid #444;
            border-radius: 5px;
            margin-top: 20px;
            display: block;
        }

        .waveform-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .waveform-option {
            display: flex;
            align-items: center;
            color: white;
        }

        .waveform-option input {
            margin-right: 10px;
        }

        .controls-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 600px) {
            .module {
                width: 100%;
                max-width: 350px;
            }
            .controls-container {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <h1>Direct Sequence Spread Spectrum (DSSS) System</h1>

    <div class="controls-container">
        <button id="powerBtn">Power ON</button>
        <button id="resetConnectionsBtn">Reset Connections</button>
    </div>

    <div id="statusMessage">Invalid connection!</div>

    <!-- Oscilloscope Modal -->
    <div id="oscilloscopeModal">
        <div id="oscilloscopeContent">
            <span id="oscilloscopeClose">&times;</span>
            <h2 style="color: white; text-align: center;">Oscilloscope Display</h2>
            
            <div class="waveform-selector">
                <div class="waveform-option">
                    <input type="radio" id="inputWave" name="waveform" value="input" checked>
                    <label for="inputWave">Input Binary Signal (NRZ)</label>
                </div>
                <div class="waveform-option">
                    <input type="radio" id="pnWave" name="waveform" value="pn">
                    <label for="pnWave">PN Code Sequence</label>
                </div>
                <div class="waveform-option">
                    <input type="radio" id="spreadWave" name="waveform" value="spread">
                    <label for="spreadWave">Spread Data Signal</label>
                </div>
                <div class="waveform-option">
                    <input type="radio" id="carrierWave" name="waveform" value="carrier">
                    <label for="carrierWave">Carrier Signal</label>
                </div>
                <div class="waveform-option">
                    <input type="radio" id="outputWave" name="waveform" value="output">
                    <label for="outputWave">DSSS Output Signal</label>
                </div>
            </div>
            
            <canvas id="oscilloscopeDisplay"></canvas>
        </div>
    </div>

    <div id="kit">
        <!-- Data Generator (Binary + NRZ) -->
        <div class="module" id="dataGenerator">
            <div class="box">
                <img src="./images/simulation_image.jpeg" class="box-image" alt="Data Generator">
            </div>
            <h2>Data Generator (NRZ)</h2>
            <div id="binaryInput" title="Toggle bits 0 or 1">
                <label><input type="checkbox" data-bit="7">7</label>
                <label><input type="checkbox" data-bit="6">6</label>
                <label><input type="checkbox" data-bit="5">5</label>
                <label><input type="checkbox" data-bit="4">4</label>
                <label><input type="checkbox" data-bit="3">3</label>
                <label><input type="checkbox" data-bit="2">2</label>
                <label><input type="checkbox" data-bit="1">1</label>
                <label><input type="checkbox" data-bit="0">0</label>
            </div>
            <div class="ports-row" style="margin-top: 15px;">
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="dataGenerator" data-index="0"></div>
                    <div class="port-label">b(t) Output</div>
                </div>
            </div>
        </div>

        <!-- PN Code Generator -->
        <div class="module" id="pnGenerator">
            <div class="box">
                <img src="./images/simulation_image.jpeg" class="box-image" alt="PN Generator">
            </div>
            <h2>PN Code Generator</h2>
            <div class="control-group">
                <div class="control-label">Chip Rate: <span id="chipRateVal">10</span> MHz</div>
                <button onclick="changeChipRate(-1)">-</button>
                <button onclick="changeChipRate(1)">+</button>
            </div>
            <div class="control-group">
                <div class="control-label">Sequence Length: <span id="seqLengthVal">7</span></div>
                <button onclick="changeSeqLength(-1)">-</button>
                <button onclick="changeSeqLength(1)">+</button>
            </div>
            <div class="ports-row" style="margin-top: 15px;">
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="pnGenerator" data-index="0"></div>
                    <div class="port-label">c(t) Output</div>
                </div>
            </div>
        </div>

        <!-- XOR Gate -->
        <div class="module" id="xorGate">
            <h2>XOR Gate (⊕)</h2>
            <div class="ports-row">
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="xorGate" data-index="0"></div>
                    <div class="port-label">b(t) Input</div>
                </div>
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="xorGate" data-index="1"></div>
                    <div class="port-label">c(t) Input</div>
                </div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="xorGate" data-index="0"></div>
                    <div class="port-label">s(t) Output</div>
                </div>
            </div>
        </div>

        <!-- Function Generator (Carrier) -->
        <div class="module" id="carrierGenerator">
            <div class="box">
                <img src="./images/simulation_image.jpeg" class="box-image" alt="Function Generator">
            </div>
            <h2>Carrier Generator</h2>
            <div class="ports-row">
                <div class="port-block"></div>
                <div class="port-block"></div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="carrierGenerator" data-index="0"></div>
                    <div class="port-label">Output</div>
                </div>
            </div>
            <div class="control-group">
                <div class="control-label">Frequency: <span id="carrierFreqVal">1</span> MHz</div>
                <button onclick="changeCarrierFreq(-0.1)">-</button>
                <button onclick="changeCarrierFreq(0.1)">+</button>
            </div>
            <div class="control-group">
                <div class="control-label">Amplitude: <span id="carrierAmpVal">5</span> V</div>
                <button onclick="changeCarrierAmp(-0.5)">-</button>
                <button onclick="changeCarrierAmp(0.5)">+</button>
            </div>
        </div>

        <!-- BPSK Modulator -->
        <div class="module" id="bpskModulator">
            <h2>BPSK Modulator</h2>
            <div class="ports-row">
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="bpskModulator" data-index="0"></div>
                    <div class="port-label">s(t) Input</div>
                </div>
                <div class="port-block">
                    <div class="port input-port" data-type="input" data-module="bpskModulator" data-index="1"></div>
                    <div class="port-label">Carrier</div>
                </div>
                <div class="port-block">
                    <div class="port output-port" data-type="output" data-module="bpskModulator" data-index="0"></div>
                    <div class="port-label">x(t) Output</div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls-container">
        <button id="showOscilloscopeBtn">Show on Oscilloscope</button>
    </div>

<script>
    // System state
    let powerOn = false;
    let connections = [];
    let selectedPort = null;
    let tempConnection = null;
    let inputsLocked = false;

    // System parameters
    let chipRate = 10; // MHz
    let sequenceLength = 7;
    let carrierFrequency = 1; // MHz
    let carrierAmplitude = 5; // V
    
    // Binary input state (8 bits)
    const binaryBits = new Array(8).fill(false);
    
    // DOM elements
    const powerBtn = document.getElementById('powerBtn');
    const resetConnectionsBtn = document.getElementById('resetConnectionsBtn');
    const showOscilloscopeBtn = document.getElementById('showOscilloscopeBtn');
    const statusMessage = document.getElementById('statusMessage');
    const oscilloscopeModal = document.getElementById('oscilloscopeModal');
    const oscilloscopeClose = document.getElementById('oscilloscopeClose');
    const oscilloscopeDisplay = document.getElementById('oscilloscopeDisplay');
    const oscilloscopeCtx = oscilloscopeDisplay.getContext('2d');
    
    // Parameter display elements
    const chipRateVal = document.getElementById('chipRateVal');
    const seqLengthVal = document.getElementById('seqLengthVal');
    const carrierFreqVal = document.getElementById('carrierFreqVal');
    const carrierAmpVal = document.getElementById('carrierAmpVal');
    
    // Waveform selection elements
    const waveformInput = document.getElementById('inputWave');
    const waveformPN = document.getElementById('pnWave');
    const waveformSpread = document.getElementById('spreadWave');
    const waveformCarrier = document.getElementById('carrierWave');
    const waveformOutput = document.getElementById('outputWave');

    // Initialize the system
    function init() {
        // Event listeners
        powerBtn.addEventListener('click', togglePower);
        resetConnectionsBtn.addEventListener('click', resetConnections);
        showOscilloscopeBtn.addEventListener('click', showOscilloscope);
        oscilloscopeClose.addEventListener('click', hideOscilloscope);
        
        // Port click handlers
        document.querySelectorAll('.port').forEach(port => {
            port.addEventListener('click', handlePortClick);
        });
        
        // Binary input toggles
        document.querySelectorAll('#binaryInput input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', updateBinaryInput);
        });
        
        // Waveform selection changes
        waveformInput.addEventListener('change', drawOscilloscope);
        waveformPN.addEventListener('change', drawOscilloscope);
        waveformSpread.addEventListener('change', drawOscilloscope);
        waveformCarrier.addEventListener('change', drawOscilloscope);
        waveformOutput.addEventListener('change', drawOscilloscope);
        
        // Initialize display
        updateParameterDisplays();
        resizeCanvas();
    }

    // Toggle power state
    function togglePower() {
        powerOn = !powerOn;
        powerBtn.textContent = powerOn ? 'Power OFF' : 'Power ON';
        powerBtn.classList.toggle('on', powerOn);
        powerBtn.classList.toggle('off', !powerOn);
        
        if (powerOn) {
            console.log("System powered ON");
        } else {
            console.log("System powered OFF");
        }
        drawOscilloscope();
    }

    // Reset all connections
    function resetConnections() {
        connections = [];
        document.querySelectorAll('.connection').forEach(el => el.remove());
        document.querySelectorAll('.connection-label').forEach(el => el.remove());
        inputsLocked = false;
        enableInputs(true);
        console.log("All connections reset");
    }

    // Handle port clicks for creating connections
    function handlePortClick(e) {
        const port = e.currentTarget;
        
        if (!powerOn) {
            showStatusMessage("System is powered off");
            return;
        }
        
        if (!selectedPort) {
            // First port selected
            selectedPort = port;
            port.classList.add('selected');
            
            if (port.dataset.type === 'output') {
                document.addEventListener('mousemove', moveTempConnection);
                document.addEventListener('mouseup', releaseTempConnection);
            }
        } else {
            // Second port selected - attempt to create connection
            if (selectedPort === port) {
                // Clicked same port - deselect
                selectedPort.classList.remove('selected');
                selectedPort = null;
                if (tempConnection) {
                    tempConnection.remove();
                    tempConnection = null;
                }
            } else if (selectedPort.dataset.type === port.dataset.type) {
                // Both inputs or both outputs - invalid
                showStatusMessage("Cannot connect two inputs or two outputs");
                selectedPort.classList.remove('selected');
                selectedPort = null;
                if (tempConnection) {
                    tempConnection.remove();
                    tempConnection = null;
                }
            } else {
                // Valid connection attempt
                if (!inputsLocked) {
                    // Before locking inputs, ensure binary input is given (at least one bit set)
                    if (!validateUserInputs()) {
                        showStatusMessage("Please provide binary input before making connections");
                        selectedPort.classList.remove('selected');
                        selectedPort = null;
                        if (tempConnection) {
                            tempConnection.remove();
                            tempConnection = null;
                        }
                        return;
                    }
                    // Lock inputs on first successful connection attempt
                    inputsLocked = true;
                    enableInputs(false);
                }
                
                createConnection(selectedPort, port);
                selectedPort.classList.remove('selected');
                selectedPort = null;
            }
        }
    }

    // Validate binary input before allowing connections
    function validateUserInputs() {
        // Validate binary input at least one checked
        const binaryCheckboxes = document.querySelectorAll('#binaryInput input[type="checkbox"]');
        for (let cb of binaryCheckboxes) {
            if (cb.checked) {
                return true;
            }
        }
        return false;
    }

    // Disable or enable all inputs and controls based on locked state
    function enableInputs(enable) {
        const allCheckboxes = document.querySelectorAll('#binaryInput input[type="checkbox"]');
        allCheckboxes.forEach(cb => cb.disabled = !enable);
    }

    function moveTempConnection(e) {
        if (!selectedPort || selectedPort.dataset.type !== 'output') return;
        const kit = document.getElementById('kit');
        const kitRect = kit.getBoundingClientRect();
        const portRect = selectedPort.getBoundingClientRect();

        const startX = portRect.left + portRect.width / 2 - kitRect.left;
        const startY = portRect.top + portRect.height / 2 - kitRect.top;
        const endX = e.clientX - kitRect.left;
        const endY = e.clientY - kitRect.top;

        if (!tempConnection) {
            tempConnection = document.createElement('div');
            tempConnection.className = 'temp-connection';
            kit.appendChild(tempConnection);
        }

        const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
        const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;

        tempConnection.style.left = startX + 'px';
        tempConnection.style.top = startY + 'px';
        tempConnection.style.width = length + 'px';
        tempConnection.style.transform = 'rotate(' + angle + 'deg)';
    }

    function releaseTempConnection(e) {
        document.removeEventListener('mousemove', moveTempConnection);
        document.removeEventListener('mouseup', releaseTempConnection);

        if (tempConnection) {
            document.getElementById('kit').removeChild(tempConnection);
            tempConnection = null;
        }

        if (!selectedPort) return;

        const hoveredElement = document.elementFromPoint(e.clientX, e.clientY);
        const targetPort = hoveredElement?.closest('.port');

        if (targetPort && targetPort !== selectedPort) {
            tryCreateConnection(selectedPort, targetPort);
        } else {
            showStatusMessage("Incomplete connection");
        }

        selectedPort.classList.remove('selected');
        selectedPort = null;
    }

    function tryCreateConnection(sourcePort, targetPort) {
        const sourceType = sourcePort.dataset.type;
        const targetType = targetPort.dataset.type;

        if (sourceType !== 'output' || targetType !== 'input') {
            showStatusMessage("Can only connect output to input");
            return false;
        }

        const targetModule = targetPort.dataset.module;
        const targetIndex = targetPort.dataset.index;

        if (connections.some(conn =>
            conn.targetModule === targetModule && conn.targetIndex === targetIndex
        )) {
            showStatusMessage("Input port already connected");
            return false;
        }

        const sourceModule = sourcePort.dataset.module;
        const sourceIndex = sourcePort.dataset.index;

        let isValid = false;
        let errorMessage = "Invalid connection for DSSS circuit";

        // Define valid connection rules for DSSS system
        if (sourceModule === 'dataGenerator' && sourceIndex === '0') {
            isValid = (targetModule === 'xorGate' && targetIndex === '0');
            errorMessage = "Data Generator must connect to XOR Gate's b(t) input";
        }
        else if (sourceModule === 'pnGenerator' && sourceIndex === '0') {
            isValid = (targetModule === 'xorGate' && targetIndex === '1');
            errorMessage = "PN Generator must connect to XOR Gate's c(t) input";
        }
        else if (sourceModule === 'xorGate' && sourceIndex === '0') {
            isValid = (targetModule === 'bpskModulator' && targetIndex === '0');
            errorMessage = "XOR Gate must connect to BPSK Modulator's s(t) input";
        }
        else if (sourceModule === 'carrierGenerator' && sourceIndex === '0') {
            isValid = (targetModule === 'bpskModulator' && targetIndex === '1');
            errorMessage = "Carrier Generator must connect to BPSK Modulator's carrier input";
        }
        else if (sourceModule === 'bpskModulator' && sourceIndex === '0') {
            isValid = false; // Output is final DSSS signal
            errorMessage = "BPSK Modulator output is the final DSSS signal";
        }

        if (!isValid) {
            showStatusMessage(errorMessage);
            return false;
        }

        createConnection(sourcePort, targetPort);
        showStatusMessage("Connection successful!", false);
        return true;
    }

    function createConnection(sourcePort, targetPort) {
        const kit = document.getElementById('kit');
        const kitRect = kit.getBoundingClientRect();
        const sourceRect = sourcePort.getBoundingClientRect();
        const targetRect = targetPort.getBoundingClientRect();

        const sourceX = sourceRect.left + sourceRect.width / 2 - kitRect.left;
        const sourceY = sourceRect.top + sourceRect.height / 2 - kitRect.top;
        const targetX = targetRect.left + targetRect.width / 2 - kitRect.left;
        const targetY = targetRect.top + targetRect.height / 2 - kitRect.top;

        const connection = document.createElement('div');
        connection.className = 'connection';
        connection.style.left = sourceX + 'px';
        connection.style.top = sourceY + 'px';

        const length = Math.sqrt(Math.pow(targetX - sourceX, 2) + Math.pow(targetY - sourceY, 2));
        const angle = Math.atan2(targetY - sourceY, targetX - sourceX) * 180 / Math.PI;

        connection.style.width = length + 'px';
        connection.style.transform = 'rotate(' + angle + 'deg)';

        kit.appendChild(connection);

        // Add click handler to remove connection with Ctrl+Click
        connection.addEventListener('click', (e) => {
            if (e.ctrlKey || e.metaKey) {
                kit.removeChild(connection);
                connections = connections.filter(conn => conn.element !== connection);
                if (connections.length === 0) {
                    inputsLocked = false;
                    enableInputs(true);
                }
            }
        });

        connections.push({
            sourceModule: sourcePort.dataset.module,
            sourceIndex: sourcePort.dataset.index,
            targetModule: targetPort.dataset.module,
            targetIndex: targetPort.dataset.index,
            element: connection
        });
    }

    // Show status message
    function showStatusMessage(message, isError = true) {
        statusMessage.textContent = message;
        statusMessage.style.backgroundColor = isError ? '#f44336' : '#4CAF50';
        statusMessage.style.display = 'block';
        setTimeout(() => {
            statusMessage.style.display = 'none';
        }, 2000);
    }

    // Update parameter displays
    function updateParameterDisplays() {
        chipRateVal.textContent = chipRate;
        seqLengthVal.textContent = sequenceLength;
        carrierFreqVal.textContent = carrierFrequency;
        carrierAmpVal.textContent = carrierAmplitude;
    }

    // Parameter adjustment functions
    function changeChipRate(delta) {
        if (inputsLocked) {
            showStatusMessage("Reset connections to modify parameters");
            return;
        }
        chipRate = Math.max(1, chipRate + delta);
        updateParameterDisplays();
    }

    function changeSeqLength(delta) {
        if (inputsLocked) {
            showStatusMessage("Reset connections to modify parameters");
            return;
        }
        sequenceLength = Math.max(3, Math.min(sequenceLength + delta, 15));
        updateParameterDisplays();
    }

    function changeCarrierFreq(delta) {
        if (inputsLocked) {
            showStatusMessage("Reset connections to modify parameters");
            return;
        }
        carrierFrequency = Math.max(0.1, carrierFrequency + delta);
        updateParameterDisplays();
    }

    function changeCarrierAmp(delta) {
        if (inputsLocked) {
            showStatusMessage("Reset connections to modify parameters");
            return;
        }
        carrierAmplitude = Math.max(0.1, carrierAmplitude + delta);
        updateParameterDisplays();
    }

    // Update binary input state
    function updateBinaryInput(e) {
        if (inputsLocked) {
            e.preventDefault();
            showStatusMessage("Reset connections to change binary input");
            return;
        }
        const bitIndex = parseInt(e.target.dataset.bit);
        binaryBits[bitIndex] = e.target.checked;
    }

    // Oscilloscope functions
    function showOscilloscope() {
        if (!powerOn) {
            showStatusMessage("Please turn power ON first");
            return;
        }
        oscilloscopeModal.style.display = 'flex';
        drawOscilloscope();
    }

    function hideOscilloscope() {
        oscilloscopeModal.style.display = 'none';
    }

    function resizeCanvas() {
        oscilloscopeDisplay.width = document.getElementById('oscilloscopeContent').offsetWidth - 40;
        oscilloscopeDisplay.height = 300;
    }

  function drawOscilloscope() {
    const canvasW = oscilloscopeDisplay.width;
    const canvasH = oscilloscopeDisplay.height;
    
    // Clear the display with a dark background
    oscilloscopeCtx.fillStyle = '#111';
    oscilloscopeCtx.fillRect(0, 0, canvasW, canvasH);
    
    // Draw grid
    oscilloscopeCtx.strokeStyle = '#333';
    oscilloscopeCtx.lineWidth = 1;
    
    // Vertical grid lines
    for (let x = 0; x < canvasW; x += canvasW / 10) {
        oscilloscopeCtx.beginPath();
        oscilloscopeCtx.moveTo(x, 0);
        oscilloscopeCtx.lineTo(x, canvasH);
        oscilloscopeCtx.stroke();
    }
    
    // Horizontal grid lines
    for (let y = 0; y < canvasH; y += canvasH / 8) {
        oscilloscopeCtx.beginPath();
        oscilloscopeCtx.moveTo(0, y);
        oscilloscopeCtx.lineTo(canvasW, y);
        oscilloscopeCtx.stroke();
    }
    
    // Center line
    oscilloscopeCtx.strokeStyle = '#666';
    oscilloscopeCtx.beginPath();
    oscilloscopeCtx.moveTo(0, canvasH/2);
    oscilloscopeCtx.lineTo(canvasW, canvasH/2);
    oscilloscopeCtx.stroke();
    
    // Determine which waveform to show
    let selectedWaveform = 'input';
    if (waveformInput.checked) selectedWaveform = 'input';
    if (waveformPN.checked) selectedWaveform = 'pn';
    if (waveformSpread.checked) selectedWaveform = 'spread';
    if (waveformCarrier.checked) selectedWaveform = 'carrier';
    if (waveformOutput.checked) selectedWaveform = 'output';
    
    // Set waveform color based on selection
    let waveColor = '#0f0'; // Green
    if (selectedWaveform === 'pn') waveColor = 'cyan';
    if (selectedWaveform === 'spread') waveColor = 'yellow';
    if (selectedWaveform === 'carrier') waveColor = 'orange';
    if (selectedWaveform === 'output') waveColor = 'purple';
    
    oscilloscopeCtx.strokeStyle = waveColor;
    oscilloscopeCtx.lineWidth = 2;
    oscilloscopeCtx.beginPath();
    
    const bits = binaryBits;
    const bitWidth = canvasW / bits.length;
    const pointsPerBit = 100;
    
    if (selectedWaveform === 'input') {
        // Draw NRZ input signal
        const highY = canvasH / 4;
        const lowY = (canvasH / 4) * 3;
        
        let x = 0;
        oscilloscopeCtx.moveTo(x, bits[0] ? highY : lowY);

        for (let i = 0; i < bits.length; i++) {
            x = i * bitWidth;
            oscilloscopeCtx.lineTo(x, bits[i] ? highY : lowY);
            oscilloscopeCtx.lineTo(x + bitWidth, bits[i] ? highY : lowY);
        }
    } 
    else if (selectedWaveform === 'pn') {
        // Draw PN sequence (simplified - square wave)
        const highY = canvasH / 4;
        const lowY = (canvasH / 4) * 3;
        const chipsPerBit = sequenceLength; // Use the current sequence length
        
        let x = 0;
        oscilloscopeCtx.moveTo(x, highY);
        
        // Generate a pseudo-random sequence based on the current sequence length
        const pnSequence = generatePNSequence(sequenceLength);
        
        for (let i = 0; i < bits.length; i++) {
            // For each bit, draw the PN sequence
            for (let c = 0; c < chipsPerBit; c++) {
                const chipValue = pnSequence[c % pnSequence.length];
                const chipX = x + (c * (bitWidth / chipsPerBit));
                oscilloscopeCtx.lineTo(chipX, chipValue ? highY : lowY);
                oscilloscopeCtx.lineTo(chipX + (bitWidth / chipsPerBit), chipValue ? highY : lowY);
            }
            x += bitWidth;
        }
    }
    else if (selectedWaveform === 'spread') {
        // Draw spread data signal (binary data XOR with PN sequence)
        const highY = canvasH / 4;
        const lowY = (canvasH / 4) * 3;
        const chipsPerBit = sequenceLength;
        
        let x = 0;
        oscilloscopeCtx.moveTo(x, highY);
        
        const pnSequence = generatePNSequence(sequenceLength);
        
        for (let i = 0; i < bits.length; i++) {
            const bitValue = bits[i];
            for (let c = 0; c < chipsPerBit; c++) {
                const chipValue = pnSequence[c % pnSequence.length];
                const spreadValue = bitValue ^ chipValue; // XOR operation
                const chipX = x + (c * (bitWidth / chipsPerBit));
                oscilloscopeCtx.lineTo(chipX, spreadValue ? highY : lowY);
                oscilloscopeCtx.lineTo(chipX + (bitWidth / chipsPerBit), spreadValue ? highY : lowY);
            }
            x += bitWidth;
        }
    }
    else if (selectedWaveform === 'carrier') {
        // Draw carrier signal
        const centerY = canvasH / 2;
        const amplitude = (carrierAmplitude / 10) * (canvasH / 4);
        
        for (let i = 0; i < bits.length; i++) {
            for (let p = 0; p <= pointsPerBit; p++) {
                const x = i * bitWidth + (p / pointsPerBit) * bitWidth;
                const angle = 2 * Math.PI * carrierFrequency * (p / pointsPerBit) * 2;
                const y = centerY - Math.sin(angle) * amplitude;
                
                if (i === 0 && p === 0) {
                    oscilloscopeCtx.moveTo(x, y);
                } else {
                    oscilloscopeCtx.lineTo(x, y);
                }
            }
        }
    }
    else if (selectedWaveform === 'output') {
        // Draw DSSS output signal (BPSK modulated)
        const centerY = canvasH / 2;
        const amplitude = (carrierAmplitude / 10) * (canvasH / 4);
        const pnSequence = generatePNSequence(sequenceLength);
        const chipsPerBit = sequenceLength;
        
        for (let i = 0; i < bits.length; i++) {
            const bitValue = bits[i];
            
            for (let c = 0; c < chipsPerBit; c++) {
                const chipValue = pnSequence[c % pnSequence.length];
                const spreadValue = bitValue ^ chipValue;
                
                // Each chip gets pointsPerBit/chipsPerBit points
                const pointsPerChip = Math.floor(pointsPerBit / chipsPerBit);
                
                for (let p = 0; p <= pointsPerChip; p++) {
                    const chipX = i * bitWidth + (c * (bitWidth / chipsPerBit));
                    const x = chipX + (p / pointsPerChip) * (bitWidth / chipsPerBit);
                    const angle = 2 * Math.PI * carrierFrequency * (p / pointsPerChip) * 2;
                    
                    // BPSK modulation: 0 = 0°, 1 = 180° phase shift
                    const phaseShift = spreadValue ? Math.PI : 0;
                    const y = centerY - Math.sin(angle + phaseShift) * amplitude;
                    
                    if (i === 0 && c === 0 && p === 0) {
                        oscilloscopeCtx.moveTo(x, y);
                    } else {
                        oscilloscopeCtx.lineTo(x, y);
                    }
                }
            }
        }
    }

    oscilloscopeCtx.stroke();

    // Add time markers
    oscilloscopeCtx.fillStyle = 'yellow';
    oscilloscopeCtx.font = '12px Arial';
    for (let i = 0; i <= bits.length; i++) {
        const x = i * bitWidth;
        oscilloscopeCtx.fillText(i.toString(), x - 5, canvasH - 10);
    }
}

// Helper function to generate a pseudo-random sequence
function generatePNSequence(length) {
    // Simple pseudo-random sequence generator
    const sequence = [];
    let register = 0b10101010; // Initial seed
    
    for (let i = 0; i < length; i++) {
        const bit = register & 1;
        sequence.push(bit);
        // Simple feedback (not a true maximal-length sequence)
        const feedback = ((register >> 0) ^ (register >> 2)) & 1;
        register = (register >> 1) | (feedback << 7);
    }
    
    return sequence;
}

// Initialize the system when the page loads
window.addEventListener('load', init);
window.addEventListener('resize', () => {
    resizeCanvas();
    if (oscilloscopeModal.style.display === 'block') {
        drawOscilloscope();
    }
});
    
    
</script>
</body>
</html>
